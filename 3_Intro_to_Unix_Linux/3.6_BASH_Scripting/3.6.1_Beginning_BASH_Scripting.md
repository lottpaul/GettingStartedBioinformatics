# 3.6.1 Beginning BASH Scripting
To begin your bash script, create a file with a `.sh` suffix.  The first line of the BASH script should tell Unix/Linux to use BASH to interpret the script - we do this using `#!/bin/bash`

Please see the [GNU Bash Manual](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html) for more indepth coverage of each of these topics.  I've taken much of this directly from the GNU Bash Manual

## Simplest BASH Script
BASH scripts can be complex or just a list of commands that you want BASH to execute.

**Template**
```bash
#!/bin/bash
command1
command2
command3
```

**Example**
```bash
#!/bin/bash
echo "Hello, My Name is Paul" >> HelloWorld.txt   # Create HelloWorld.txt file
wc HelloWorld.txt # Count the characters, words, lines in HelloWorld.txt
ls -alh # List all files in the current directory
```

---- 

## Taking Next Steps

### Single Quotes
Characters between single quotes `'` have their values preserved - no variable expansion 

```bash
$ echo 'Hello you are currently at: ${PWD}'
Hello you are currently at ${PWD} 
```

### Double Quotes
Characters between double quotes `"` have their values preserved - with the exception the `$`, `\``, or `\\`.
Variables in double quoted strings will be expanded to the value of the variable

```bash
$ echo "Hello you are currently at: ${PWD}"
Hello you are currently at /home/plott 
```

### Escape Characters and ANSI-C Quoting

In some cases you may want to use symbols such as `'`, `"`, `$`, `@`, `!` in your string - however it could be 
interpreted by Bash as a function, object, variable.  In order to ensure that it knows to use the literal value
we prefix the character with `\\` a forward slash.  This tells Bash to use the character and not to try and
expand it's value.

`\\` = backslash

`\'` = single quote

`\"` = double quote

`\?` = question mark

There are also some instances were you want to place a tab, newline, or carriage-return in you string. Many
programming languages use the following syntax:

`\n` = Newline character
`\t` = Tab Character
`\r` = Carriage Return

## BASH Programming Language Commands and Syntax
In BASH allows you chain many commands together and also provides a programming language to automate many
tasks.  However, it's important to remember that when we're programming BASH we want to avoid naming variables
certain with words and characters because they have special meaning in BASH.  The list following table contains
a list of reserved words and characters.  

| Reserved Words and Characters          |
| -------------------------------------- |
| if then elif else fi time              |
| for in until while do	done             |
| case esac coproc select function       |
| {	}	[[	]]	!  $ ' " @  |  ?         |

As we go through the remaining lessons on BASH, you'll see how BASH uses these reserved words and characters.

### Commenting Code
It's always a good idea to comment your code. BASH uses the `#` (hash/number sign) to begin a comment. Any
point within a line that has an unquoted `#` will be interpreted as the start of a comment.

Typically, in any program you want to provide information about 
 - What the main purpose of the program is
 - How to use your program  (Provide an template usage statement and an example is also great)
 - What are the required or optional inputs 
 - What are the outputs of your program (is it writing to a file or STDOUT)

It is typical to provide this information at the beginning of the script as a **usage statement** for 
anyone who is going to use your script.

Also, comment anything that you or others might need help to understand in the future.  Chances are 
that if it's a script you are using - you'll want to come back later to add functionality.
Comments provide a great resource for you to refresh your memory about how and why you did something
in a certain way.

```bash
#!/bin/bash
# Hello World - just a simple bash script to say Hello
# There are no inputs and it just outputs "Hello World" to the STDOUT
echo "Hello World"
```

### Variables
Variables in BASH aren't typed - meaning they can store only a certain type of data.  A variable in BASH can contain 
any type of data: a number (Integer or Float), a character, or string.  All you need to do is make an assignment
to the variable.

Variable names should begin with a letter or underscore and may contain only letters, underscore, and numbers.

In BASH, the coding convention is that CAPITALIZED variables represent system variables set by the Operating System. For example, PWD, HOME,
USER, HOSTNAME.

When you are creating variables for a script, you should use lowercase letters. It is also typically good practice to
use descriptive variable names.  Try not to just name all your variables as single letters (ie. `x`, `i`, `n`,...)

```bash
#!/bin/bash
# This script calls a python script called filter_calls.py 
# It filters out reads that have a mapping score less than 
# a provided threshold

# Calls are output to STDOUT

mapping_score_threshold=30    #Mapping score Threshold

#TODO:  I think it'd be good to add the ability to pass in a file to the script
filter_calls.py -mapping_threshold_gt $mapping_score_threshold
```

### Getting Variables from Command Line Arguments and Options
In BASH, arguments following the command are passed into the script as automatically assigned variables.   

The first argument/option passed into the script is assigned as `$1`

The second argument/option passed into the script is assigned as `$2`

and so on.  

For the following script, called `echo_arguments.sh` 

```bash
#!/bin/bash
echo $1
echo $2
echo $3
```

If we called it with the following arguments:

```bash
$ echo_arguments.sh Hello 1
Hello    <- Value of $1, which is Hello
1        <- Value of $2, which is 1
         <- Value of $3, which is nothing
```

#### Other special Variables

| Special Variables | Description                    | 
| ----------------- | ------------------------------ |
| $* | String of all arguments passed into script    |
| $@ | List of all arguments passed into script      |
| $# | Number of arguments passed into script        |
| $1..$9| Stores the nth argument passed into script |
| $0 | Is assigned the name of the current script    | 
| $$ | Process ID of the current shell               |
| $_ | Last argument passed to the script            |
| $- | Prints the current set of BASH options script was executed with  |
| $! | Contains the Process ID of the last background process   |
| $? | Contains the status code of the last process  |


```bash
#!/bin/bash
# Echo special variables when run
# Make certain to pass arguments to the script so $*, $@, $#, $1, $2 are assigned
echo "\$* = $*"   #Prints the string of arguments
echo "\$@ = $@"   #Prints the List of arguments
echo "\$# = $#"   #Prints the number of arguments
echo "\$1 = $1"   #Prints the first argument
echo "\$2 = $2"   #Prints the second argument
echo "\$0 = $0"   #Prints the name of the script
echo "\$$ = $$"   #Prints the current PID
echo "\$_ = $_"   #Prints the last argument
echo "\$- = $-"   #Prints BASH options flags in effect
echo "\$! = $!"   #Prints the last background process PID
echo "\$? = $?"   #Prints the last background process return value
```

#### Saving Command Outputs to variable
In BASH scripts, you can save the output from one program in a variable for use in a new command.

```bash
variable=$(cmd)  # Saves the output from the cmd to the variable
```

**Example**
```bash
#!/bin/bash
text_files=$(ls -1 *.txt)
num_text_files=$(ls -1 *.txt | wc -l) 
echo "We found $num_text_files text files"
echo "They are: $text_files"
```

There is an older syntax that you may also run across that does the same thing above
It uses the backticks (\`) to denote a command to run in BASH and then assign it to a variable

```bash
#!/bin/bash
date_time=`date`
echo "Today it is: $date_time"
```

The `$()` syntax is the newer syntax and the preferred method to use, but you'll still see backticks
alot in older code or from people who were trained on older BASH.

### Arrays
In BASH, an `array` is a list of items (numbers, words, characters, variables,..), it can be 
assigned by getting a list of items from a function or assigned.  

To initialize an array, you just need to surround a group of items with parenthesis `(` and `)` and assign it to a variable.
BASH uses spaces as delimiters between items, not commas.

```bash
#!/bin/bash
items=("First" 2 "Three" 4.02 "Fifth" $HOME)   # Assign an array
echo $items                                    # Print first item of array
echo ${items[@]}                               # Print whole array
```

You'll notice that this script didn't print the whole array when we passed `$items` but rather
only printed the first item.  That is because BASH by default thinks that any variable is just 
a single object instead of a list of object.  To ensure that a variable is interpreted as a 
`array`, we need to use the proper syntax for `arrays`

| Array Syntax | Description |
| ------------ | ----------- |
| name=()      | Create an empty array                                             |
| name=(a b c) | Create an array with 3 items                                      |
| ${name[@]}   | Treat variable as array and return all elements in the array      |
| ${name[0]}   | Get the first element in the array                                |
| ${name[1]}   | Get the second element in the array                               |
| ${name[n]}   | Get the nth+1 element in the array                                |
| ${name[@]:s:n} | Get `n` elements starting at index `s`                          |
| ${!name[@]}  | Get array indices for the array (0,1,2,...)                       |
| ${#name[@]}  | Get the size/length of the array, number of elements in the array |
| name[0]='Z'  | Overwrite first element with the character 'Z'                    |
| name+=(d e f)| Append the items to the end of the array                          |
| name=($(cmd))| Save output from `cmd` as an array                                |

```bash
#!/bin/bash
text_files=($(ls -1 *.txt))   #Save output from ls -1 *.txt to an array
num_text_files=$(ls -1 *.txt | wc -l) 
echo "We found $num_text_files text files"
echo "They are: ${text_files[@]}"  # Print the array of items
```

## Wrapping your Lines
Sometimes, you may want to print large amounts of text, but don't necessarily want to `echo` each line separately.
BASH allows you to wrap lines of code or text by ending the line with `\`.  If the lines ends with a `\` then BASH
continues the command on the next line.  In this way you can, wrap your code or text.

```bash
#!/bin/bash
paragraph="Although Nature needs thousands or millions of years to \
create a new species, man needs only a few dozen years to destroy one."
echo $paragraph
```

## Input/Ouput Streams (I/O)
Unix/Linux provides three different I/O streams to the terminal: **STDIN**, **STDOUT**, and **STDERR**. 

**STDIN**: takes input from the user.  Also, referred as File descriptor 0
**STDOUT**: Standard printed output from program/process Also, referred to as File descriptor 1
**STDERR**: Printed error messages or other warning messages. Also, referred to as File descriptor 2

It is standard practice to print information you want the user to see to **STDOUT**.  If an error occurs or you want to warn
the user about some issue, you print the output to **STDERR**

Some programs may output some information to **STDOUT** or **STDERR** that you want to save to a file or pass along to another process.

To do this we can use the BASH I/O redirection,

| Syntax  | Description |
| ---------  | ------------|
| > FILE     | Write STDOUT to FILE, overrite FILE if already exists              |
| 1> FILE    | Write STDOUT to FILE (See Stream File descriptors above)           |
| 2> FILE    | Write STDERR to FILE (See Stream File descriptors above)           |
| >> FILE    | Appends STDOUT to FILE, Creates FILE if it doesn't already exist   |
| &> FILE    | Write STDOUT and STDERR to FILE, overwrites FILE if already exists |
| &>> FILE   | Appends STDOUT and STDERR to FILE                                  |
| 2>&1       | Redirect STDERR to STDOUT    (See Streams File descriptor above)   |
| < FILE     | STDIN taken from FILE                                              |


## Piping
Piping using the character `|`.  Piping means passing the stream output from one program to another program.

| Syntax | Description |
| ------ | ----------- |
| prog1 \| prog2    | Pipe STDOUT from `prog1` to `prog2`             |
| prog1 \|& prog2   | Pipe STDOUT and STDERR from `prog1` to `prog2`  |

---
In the above section, we've went over some of the basics of assigning variables, running commands, piping, redirecting inputs/outputs from terminal, and printing those to terminal or redirecting them to a file.  In the previous section the program always ran in a clearly delineated path from the first line of the script to then end of the script.

## Process Control
In this next section we're going to dive into **Process Control** - this is the functionality of control the flow of the scripts execution.  It could be looping through elements using `while` or `for` loops, or using conditionals and case statements to determine what gets run dependent upon the inputs or values of variables.

### For Loops
For loops is a simple type of looping system that allows us to run code on each element or a set number of times. In the basic for loop, we iterate over a list of items, each item is first assigned to a temporary variable and then the command between `do` and `done` is executed on that value.

`For` loops are able to loop over:
 
 1. Array:   `${array[@]}`
 2. Sequence of Numbers:  `{START..END..STEP}`
 3. String:  `"First Second Third"`  - **Note:** Spaces or `|` are used as delimiters to define different elements in the string
 4. Command outputs: `$(cmd)`


 **Basic For-loop Syntax**
```bash
for temporary_variable in [sequence, array, command, or range]; do
   command(s)
done
```

**Example using an Array**
```bash
#!/bin/bash
files = ($(ls -1))   #Gets the list of files in the current directory
for file in ${files[@]};do  #Process through each file and assign it to the file variable
  echo $file                #Print the file variable to STDOUT
done
```


**Example using Sequence of Items**
```bash
#!/bin/bash
for n in 1 2 3 4 5 6 7 8 9 10;do  #Process through element of the numbers 1-10
  echo $n                #Print the number (n) variable to STDOUT
done
```

**Example using Command**
```bash
#!/bin/bash
for fn in $(ls -1);do  #Process through element - files returned by running ls command
  echo $fn                #Print the filename in fn variable
done

for n in $(seq 2 2 20);do  #Process through element - starting at 2 incremented by 2 until 20
  echo $n                #Print the value of n variable
done

```

**Example using Ranges (BASH 3+)**
```bash
#!/bin/bash
for n in {1..10};do  #Process through element of the numbers 1-10
  echo $n                #Print the number (n) variable to STDOUT
done
```

#### C-style For Loop Syntax
BASH also supports a For loop syntax similar to C/C++, where you have 3 different elements in the For Loop

1. Intial Starting Value
2. Conditional
3. Value Step

```bash
#/bin/bash
for ((n=1; n<=20;n++));do  #Initial value of n=1 proceeds while n is less than or equal to 20, each time through the loop n is increased by 1
  echo $n
done
```

### Other Important For Loop Commands
When proceeding through a `for` loop, you may want to skip executing some bit of code or exit the for loop prior to processing all the elements.

There are two different keywords that provide you with this ability

| Keyword |  Description | 
| ------- | ------------ |
| break    | Exits the loop immediately |
| continue | Skips to the next iteration step of the loop |

### While Loops

### Conditionals

### Case Statements
